{"ast":null,"code":"import _slicedToArray from \"/home/emarks/brown-egg-hunt/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nexport default function compareVersions(v1, v2) {\n  // validate input and split into segments\n  var n1 = validateAndParse(v1);\n  var n2 = validateAndParse(v2); // pop off the patch\n\n  var p1 = n1.pop();\n  var p2 = n2.pop(); // validate numbers\n\n  var r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n}\nexport var validate = function validate(v) {\n  return typeof v === 'string' && /^[v\\d]/.test(v) && semver.test(v);\n};\nexport var compare = function compare(v1, v2, operator) {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  var res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\nexport var satisfies = function satisfies(v, r) {\n  // if no range operator then \"=\"\n  var m = r.match(/^([<>=~^]+)/);\n  var op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(v, r, op); // else range of either \"~\" or \"^\" is assumed\n\n  var _validateAndParse = validateAndParse(v),\n      _validateAndParse2 = _slicedToArray(_validateAndParse, 3),\n      v1 = _validateAndParse2[0],\n      v2 = _validateAndParse2[1],\n      v3 = _validateAndParse2[2];\n\n  var _validateAndParse3 = validateAndParse(r),\n      _validateAndParse4 = _slicedToArray(_validateAndParse3, 3),\n      r1 = _validateAndParse4[0],\n      r2 = _validateAndParse4[1],\n      r3 = _validateAndParse4[2];\n\n  if (compareStrings(v1, r1) !== 0) return false;\n\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n}; // export CJS style for parity\n\ncompareVersions.validate = validate;\ncompareVersions.compare = compare;\ncompareVersions.sastisfies = satisfies;\nvar semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nvar validateAndParse = function validateAndParse(v) {\n  if (typeof v !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  var match = v.match(semver);\n\n  if (!match) {\n    throw new Error(\"Invalid argument not valid semver ('\".concat(v, \"' received)\"));\n  }\n\n  match.shift();\n  return match;\n};\n\nvar isWildcard = function isWildcard(s) {\n  return s === '*' || s === 'x' || s === 'X';\n};\n\nvar tryParse = function tryParse(v) {\n  var n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nvar forceType = function forceType(a, b) {\n  return typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n};\n\nvar compareStrings = function compareStrings(a, b) {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n\n  var _forceType = forceType(tryParse(a), tryParse(b)),\n      _forceType2 = _slicedToArray(_forceType, 2),\n      ap = _forceType2[0],\n      bp = _forceType2[1];\n\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nvar compareSegments = function compareSegments(a, b) {\n  for (var i = 0; i < Math.max(a.length, b.length); i++) {\n    var r = compareStrings(a[i] || 0, b[i] || 0);\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nvar operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nvar allowedOperators = Object.keys(operatorResMap);\n\nvar assertValidOperator = function assertValidOperator(op) {\n  if (typeof op !== 'string') {\n    throw new TypeError(\"Invalid operator type, expected string but got \".concat(typeof op));\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\"Invalid operator, expected one of \".concat(allowedOperators.join('|')));\n  }\n};","map":{"version":3,"sources":["/home/emarks/brown-egg-hunt/node_modules/compare-versions/index.mjs"],"names":["compareVersions","v1","v2","n1","validateAndParse","n2","p1","pop","p2","r","compareSegments","split","validate","v","test","semver","compare","operator","assertValidOperator","res","operatorResMap","includes","satisfies","m","match","op","v3","r1","r2","r3","compareStrings","sastisfies","TypeError","Error","shift","isWildcard","s","tryParse","n","parseInt","isNaN","forceType","a","b","String","ap","bp","i","Math","max","length","allowedOperators","Object","keys","indexOf","join"],"mappings":";AAAA,eAAe,SAASA,eAAT,CAAyBC,EAAzB,EAA6BC,EAA7B,EAAiC;AAC9C;AACA,MAAMC,EAAE,GAAGC,gBAAgB,CAACH,EAAD,CAA3B;AACA,MAAMI,EAAE,GAAGD,gBAAgB,CAACF,EAAD,CAA3B,CAH8C,CAK9C;;AACA,MAAMI,EAAE,GAAGH,EAAE,CAACI,GAAH,EAAX;AACA,MAAMC,EAAE,GAAGH,EAAE,CAACE,GAAH,EAAX,CAP8C,CAS9C;;AACA,MAAME,CAAC,GAAGC,eAAe,CAACP,EAAD,EAAKE,EAAL,CAAzB;AACA,MAAII,CAAC,KAAK,CAAV,EAAa,OAAOA,CAAP,CAXiC,CAa9C;;AACA,MAAIH,EAAE,IAAIE,EAAV,EAAc;AACZ,WAAOE,eAAe,CAACJ,EAAE,CAACK,KAAH,CAAS,GAAT,CAAD,EAAgBH,EAAE,CAACG,KAAH,CAAS,GAAT,CAAhB,CAAtB;AACD,GAFD,MAEO,IAAIL,EAAE,IAAIE,EAAV,EAAc;AACnB,WAAOF,EAAE,GAAG,CAAC,CAAJ,GAAQ,CAAjB;AACD;;AAED,SAAO,CAAP;AACD;AAED,OAAO,IAAMM,QAAQ,GAAG,SAAXA,QAAW,CAACC,CAAD;AAAA,SACtB,OAAOA,CAAP,KAAa,QAAb,IAAyB,SAASC,IAAT,CAAcD,CAAd,CAAzB,IAA6CE,MAAM,CAACD,IAAP,CAAYD,CAAZ,CADvB;AAAA,CAAjB;AAGP,OAAO,IAAMG,OAAO,GAAG,SAAVA,OAAU,CAACf,EAAD,EAAKC,EAAL,EAASe,QAAT,EAAsB;AAC3C;AACAC,EAAAA,mBAAmB,CAACD,QAAD,CAAnB,CAF2C,CAI3C;AACA;;AACA,MAAME,GAAG,GAAGnB,eAAe,CAACC,EAAD,EAAKC,EAAL,CAA3B;AAEA,SAAOkB,cAAc,CAACH,QAAD,CAAd,CAAyBI,QAAzB,CAAkCF,GAAlC,CAAP;AACD,CATM;AAWP,OAAO,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAACT,CAAD,EAAIJ,CAAJ,EAAU;AACjC;AACA,MAAMc,CAAC,GAAGd,CAAC,CAACe,KAAF,CAAQ,aAAR,CAAV;AACA,MAAMC,EAAE,GAAGF,CAAC,GAAGA,CAAC,CAAC,CAAD,CAAJ,GAAU,GAAtB,CAHiC,CAKjC;;AACA,MAAIE,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B,OAAOT,OAAO,CAACH,CAAD,EAAIJ,CAAJ,EAAOgB,EAAP,CAAd,CANG,CAQjC;;AACA,0BAAqBrB,gBAAgB,CAACS,CAAD,CAArC;AAAA;AAAA,MAAOZ,EAAP;AAAA,MAAWC,EAAX;AAAA,MAAewB,EAAf;;AACA,2BAAqBtB,gBAAgB,CAACK,CAAD,CAArC;AAAA;AAAA,MAAOkB,EAAP;AAAA,MAAWC,EAAX;AAAA,MAAeC,EAAf;;AACA,MAAIC,cAAc,CAAC7B,EAAD,EAAK0B,EAAL,CAAd,KAA2B,CAA/B,EAAkC,OAAO,KAAP;;AAClC,MAAIF,EAAE,KAAK,GAAX,EAAgB;AACd,WAAOf,eAAe,CAAC,CAACR,EAAD,EAAKwB,EAAL,CAAD,EAAW,CAACE,EAAD,EAAKC,EAAL,CAAX,CAAf,IAAuC,CAA9C;AACD;;AACD,MAAIC,cAAc,CAAC5B,EAAD,EAAK0B,EAAL,CAAd,KAA2B,CAA/B,EAAkC,OAAO,KAAP;AAClC,SAAOE,cAAc,CAACJ,EAAD,EAAKG,EAAL,CAAd,IAA0B,CAAjC;AACD,CAjBM,C,CAmBP;;AACA7B,eAAe,CAACY,QAAhB,GAA2BA,QAA3B;AACAZ,eAAe,CAACgB,OAAhB,GAA0BA,OAA1B;AACAhB,eAAe,CAAC+B,UAAhB,GAA6BT,SAA7B;AAEA,IAAMP,MAAM,GACV,4IADF;;AAGA,IAAMX,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACS,CAAD,EAAO;AAC9B,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACzB,UAAM,IAAImB,SAAJ,CAAc,kCAAd,CAAN;AACD;;AACD,MAAMR,KAAK,GAAGX,CAAC,CAACW,KAAF,CAAQT,MAAR,CAAd;;AACA,MAAI,CAACS,KAAL,EAAY;AACV,UAAM,IAAIS,KAAJ,+CAAiDpB,CAAjD,iBAAN;AACD;;AACDW,EAAAA,KAAK,CAACU,KAAN;AACA,SAAOV,KAAP;AACD,CAVD;;AAYA,IAAMW,UAAU,GAAG,SAAbA,UAAa,CAACC,CAAD;AAAA,SAAOA,CAAC,KAAK,GAAN,IAAaA,CAAC,KAAK,GAAnB,IAA0BA,CAAC,KAAK,GAAvC;AAAA,CAAnB;;AAEA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACxB,CAAD,EAAO;AACtB,MAAMyB,CAAC,GAAGC,QAAQ,CAAC1B,CAAD,EAAI,EAAJ,CAAlB;AACA,SAAO2B,KAAK,CAACF,CAAD,CAAL,GAAWzB,CAAX,GAAeyB,CAAtB;AACD,CAHD;;AAKA,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAACC,CAAD,EAAIC,CAAJ;AAAA,SAChB,OAAOD,CAAP,KAAa,OAAOC,CAApB,GAAwB,CAACC,MAAM,CAACF,CAAD,CAAP,EAAYE,MAAM,CAACD,CAAD,CAAlB,CAAxB,GAAiD,CAACD,CAAD,EAAIC,CAAJ,CADjC;AAAA,CAAlB;;AAGA,IAAMb,cAAc,GAAG,SAAjBA,cAAiB,CAACY,CAAD,EAAIC,CAAJ,EAAU;AAC/B,MAAIR,UAAU,CAACO,CAAD,CAAV,IAAiBP,UAAU,CAACQ,CAAD,CAA/B,EAAoC,OAAO,CAAP;;AACpC,mBAAiBF,SAAS,CAACJ,QAAQ,CAACK,CAAD,CAAT,EAAcL,QAAQ,CAACM,CAAD,CAAtB,CAA1B;AAAA;AAAA,MAAOE,EAAP;AAAA,MAAWC,EAAX;;AACA,MAAID,EAAE,GAAGC,EAAT,EAAa,OAAO,CAAP;AACb,MAAID,EAAE,GAAGC,EAAT,EAAa,OAAO,CAAC,CAAR;AACb,SAAO,CAAP;AACD,CAND;;AAQA,IAAMpC,eAAe,GAAG,SAAlBA,eAAkB,CAACgC,CAAD,EAAIC,CAAJ,EAAU;AAChC,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAC,CAACQ,MAAX,EAAmBP,CAAC,CAACO,MAArB,CAApB,EAAkDH,CAAC,EAAnD,EAAuD;AACrD,QAAMtC,CAAC,GAAGqB,cAAc,CAACY,CAAC,CAACK,CAAD,CAAD,IAAQ,CAAT,EAAYJ,CAAC,CAACI,CAAD,CAAD,IAAQ,CAApB,CAAxB;AACA,QAAItC,CAAC,KAAK,CAAV,EAAa,OAAOA,CAAP;AACd;;AACD,SAAO,CAAP;AACD,CAND;;AAQA,IAAMW,cAAc,GAAG;AACrB,OAAK,CAAC,CAAD,CADgB;AAErB,QAAM,CAAC,CAAD,EAAI,CAAJ,CAFe;AAGrB,OAAK,CAAC,CAAD,CAHgB;AAIrB,QAAM,CAAC,CAAC,CAAF,EAAK,CAAL,CAJe;AAKrB,OAAK,CAAC,CAAC,CAAF;AALgB,CAAvB;AAQA,IAAM+B,gBAAgB,GAAGC,MAAM,CAACC,IAAP,CAAYjC,cAAZ,CAAzB;;AAEA,IAAMF,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACO,EAAD,EAAQ;AAClC,MAAI,OAAOA,EAAP,KAAc,QAAlB,EAA4B;AAC1B,UAAM,IAAIO,SAAJ,0DAC8C,OAAOP,EADrD,EAAN;AAGD;;AACD,MAAI0B,gBAAgB,CAACG,OAAjB,CAAyB7B,EAAzB,MAAiC,CAAC,CAAtC,EAAyC;AACvC,UAAM,IAAIQ,KAAJ,6CACiCkB,gBAAgB,CAACI,IAAjB,CAAsB,GAAtB,CADjC,EAAN;AAGD;AACF,CAXD","sourcesContent":["export default function compareVersions(v1, v2) {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2);\n\n  // pop off the patch\n  const p1 = n1.pop();\n  const p2 = n2.pop();\n\n  // validate numbers\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n}\n\nexport const validate = (v) =>\n  typeof v === 'string' && /^[v\\d]/.test(v) && semver.test(v);\n\nexport const compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator);\n\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  const res = compareVersions(v1, v2);\n\n  return operatorResMap[operator].includes(res);\n};\n\nexport const satisfies = (v, r) => {\n  // if no range operator then \"=\"\n  const m = r.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '=';\n\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~') return compare(v, r, op);\n\n  // else range of either \"~\" or \"^\" is assumed\n  const [v1, v2, v3] = validateAndParse(v);\n  const [r1, r2, r3] = validateAndParse(r);\n  if (compareStrings(v1, r1) !== 0) return false;\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n};\n\n// export CJS style for parity\ncompareVersions.validate = validate;\ncompareVersions.compare = compare;\ncompareVersions.sastisfies = satisfies;\n\nconst semver =\n  /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = (v) => {\n  if (typeof v !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  const match = v.match(semver);\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${v}' received)`);\n  }\n  match.shift();\n  return match;\n};\n\nconst isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = (v) => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) =>\n  typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || 0, b[i] || 0);\n    if (r !== 0) return r;\n  }\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1],\n};\n\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = (op) => {\n  if (typeof op !== 'string') {\n    throw new TypeError(\n      `Invalid operator type, expected string but got ${typeof op}`\n    );\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\n      `Invalid operator, expected one of ${allowedOperators.join('|')}`\n    );\n  }\n};\n"]},"metadata":{},"sourceType":"module"}